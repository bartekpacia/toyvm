// Package vm implements a very simple virtual machine.
package vm

import (
	"fmt"
	"os"
	"sync"
)

// gpRegister is a general-purpose register.
type gpRegister struct {
	value uint32
}

const (
	FlagZF = iota + 1 // zero flag
	FlagCF = iota     // carry flag
)

const (
	IntMemoryError   = iota
	IntDivisionError = iota
	IntGeneralError  = iota

	IntPit     = 8 // generated by programmable timer
	IntConsole = 9 // generated by console

)

var MaskableInterrupts = []int{IntPit, IntConsole}

type VM struct {
	memory     *Memory
	registers  []gpRegister
	pc         *gpRegister // program counter
	sp         *gpRegister // stack pointer
	fr         uint32      // flag register
	terminated bool
	opcodes    map[byte]opcode

	interruptQueue      []int
	interruptQueueMutex sync.Mutex

	deferredQueue []func()
}

func NewVM() *VM {
	var registers []gpRegister
	for i := 0; i < 16; i++ {
		registers = append(registers, gpRegister{})
	}

	vm := VM{
		memory:     &Memory{mem: make([]byte, 64*1024)}, // 64KB
		registers:  registers,
		pc:         &registers[14],
		sp:         &registers[15],
		fr:         0,
		terminated: false,

		interruptQueue:      make([]int, 0),
		interruptQueueMutex: sync.Mutex{},

		deferredQueue: make([]func(), 0),
	}

	vm.sp.value = 0x10000

	return &vm
}

// crash terminates the virtual machine on critical error
func (vm *VM) crash() {
	vm.terminated = true

	fmt.Println("the virtual machine entered an erroneous state and is terminating")
	fmt.Println("register values at termination:")
	for ri, r := range vm.registers {
		fmt.Printf("\tr%d = %x\n", ri, r.value)
	}
}

func (vm *VM) interrupt(interrupt int) {
	vm.interruptQueueMutex.Lock()
	defer vm.interruptQueueMutex.Unlock()

	vm.interruptQueue = append(vm.interruptQueue, interrupt)
}

func (vm *VM) runSingleStep() error {
	// If there is any interrupt on the queue, we need to know about it now.
	err := vm.processInterruptQueue()
	if err != nil {
		return fmt.Errorf("something failed hard: %v", err)
	}

	// Check if there is anything in the defered queue. If so, process it now.
	for len(vm.deferredQueue) != 0 {
		q := vm.deferredQueue
		action, queue := q[len(q)-1], q[:len(q)-1]
		vm.deferredQueue = queue
		action()
	}

	// Proceed with normal execution
	opcodeByte, err := vm.memory.FetchByte(uint16(vm.pc.value))
	if err != nil {
		vm.interrupt(IntMemoryError)
		return fmt.Errorf("failed to fetch opcode: %v", err)
	}

	opcode, ok := vm.opcodes[opcodeByte]
	if !ok {
		vm.interrupt(IntGeneralError)
	}

	length := opcode.length
	argBytes, err := vm.memory.FetchMany(uint16(vm.pc.value+1), length)
	if err != nil {
		vm.interrupt(IntMemoryError)
		return fmt.Errorf("failed to fetch arg bytes: %v", err)
	}

	handler := opcode.handler
	vm.pc.value = vm.pc.value + 1 + uint32(length)
	handler(vm, argBytes)
	return nil
}

func (vm *VM) LoadMemoryFromFile(addr uint16, filename string) error {
	data, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read code from file %s: %w", filename, err)
	}

	err = vm.memory.StoreMany(addr, data)
	if err != nil {
		return fmt.Errorf("failed to load code to memory: %w", err)
	}

	return nil
}

func (vm *VM) Run() {
	for !vm.terminated {
		vm.runSingleStep()
	}

	// vm.devConsole.terminate()
	// vm.devPIT.terminate()
}
