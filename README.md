# toy vm

Pure Go implementation of a small virtual machine described in [Gynvael Coldwind's book][book].

## Usage

Build executable:

```console
$ go build
```

The above generates the `toyvm` executable.

There are a few sample programs in [examples](./examples).
To run them, you have to compile them first with Netwide Assembler (nasm). To do it, install nasm and then run `make`.

Once you hvae the binaries, you can run a sample program:

```console
$ ./toyvm examples/hello.bin 
Hello, World!
```

There are quite a few tests written. If not for them, I'd have lost my sanity long time ago. To run the tests:

```console
$ go test ./vm
```

# Instruction set

Variable-length, little-endian.

The tables of opcodes were created with Gemini 1.5 Pro with the book PDF (pages 68â€“89)
attached.
The prompt I used can be found in `prompt.txt` file.

## 1. Data copying instructions

| Opcode (hex) | Mnemonic | Mnemonic name  | Parameters      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-------------|:---------|:---------------|:----------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 00           | VMOV     | **move**       | `rdst`, `rsrc`  | Copies the value of the `rsrc` register to `rdst`. Equivalent to the high-level `rdst=rsrc`.<br>Example of copying the value of R5 to R2:<br>VMOV R2, R5<br>Machine code [29]: 00 02 05                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 01           | VSET     | **set**        | `rdst`, `imm32` | Sets the value of the `rdst` register to the given constant. Equivalent to the high-level `rdst=imm32`.<br>Example of setting the value of the R4 register to `0x00001234`:<br>VSET R4, `0x1234`<br>Machine code: 01 04 34 12 00 00<br>As I mentioned earlier, the constant is written using the Little Endian method, so the least significant bytes have priority - hence the `0x34` byte is at the beginning.                                                                                                                                                                                                                  |
| 02           | VLD      | **load**       | `rdst`, `rsrc`  | Copies 32 bits of data from the operating memory from the address indicated in the `rsrc` register to the register indicated in `rdst`.<br>In C, this operation could be written as: `rdst=*(uint32_t*)rsrc;`.<br>Example of reading 32 bits of data from the operating memory from the address `0x1234` to the R1 register:<br>VSET R2, `0x1234`<br>VLD R1, R2<br>Machine code:<br>01 02 34 12 00 00<br>02 01 02<br>It should be noted that reading 32 bits (4 bytes) from the address `0x1234` should be understood as reading four consecutive bytes from the addresses (in order): `0x1234`, `0x1235`, `0x1236` and `0x1237`. |
| 03           | VST      | **store**      | `rdst`, `rsrc`  | Copies 32 bits of data from the `rsrc` register to the operating memory at the address indicated in the `rdst` register.<br>In C, this operation could be written as:<br>`*(uint32_t*)rdst = rsrc;`<br>Example: (writing the value `0x12345678` to the address `0x1234`)<br>VSET R9, `0x1234`<br>VSET R5, `0x12345678`<br>VST R9, R5<br>Machine code:<br>01 09 34 12 00 00<br>01 05 78 56 34 12<br>03 09 05                                                                                                                                                                                                                       |
| 04           | VLDB     | **load byte**  | `rdst`, `rsrc`  | Copies 8 bits of data from the operating memory from the address indicated in the `rsrc` register to the register indicated in `rdst`.<br>In C, this operation could be written as: `rdst=*(uint8_t*)rsrc;`.<br>Example of reading 8 bits from operating memory from the address `0x1234` to the R1 register:<br>VSET R3, `0x1234`<br>VLDB R1, R3<br>Machine code:<br>01 03 34 12 00 00<br>04 01 03                                                                                                                                                                                                                               |
| 05           | VSTB     | **store byte** | `rdst`, `rsrc`  | Copies the lower 8 bits of data from the `rsrc` register to the operating memory at the address indicated in the `rdst` register.<br>In C, this operation could be written as: `*(uint8_t*)rdst = rsrc;`<br>Example of writing byte `0x41` to the address `0x1234;`<br>VSET R1, `0x41`<br>VSET R2, `0x1234`<br>VSTB R2, R1<br>Machine code:<br>01 01 41 00 00 00<br>01 02 34 12 00 00<br>05 02 01                                                                                                                                                                                                                                 |

## 2. Arithmetic and logic instructions

| Opcode (hex) | Mnemonic | Mnemonic name (EN) | Params     | Description                                                                                                                                                                                                                                                                                                                                                                                        |
|:-------------|:---------|:-------------------|:-----------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 10           | VADD     | **add**            | rdst, rsrc | Adds the values of registers rsrc and rdst and stores the result in rdst. Equivalent to `rdst += rsrc`.<br>Example of adding 5 to 8:<br>VSET R1, 5<br>VSET R2, 8<br>VADD R2, R1<br>Machine code:<br>01 01 05<br>01 02 08<br>10 02 01                                                                                                                                                               |
| 11           | VSUB     | **subtract**       | rdst, rsrc | Subtracts the value of register rsrc from rdst and stores the result in rdst. Equivalent to `rdst -= rsrc`.<br>Example of zeroing register R1:<br>VSUB R1, R1<br>Machine code:<br>10 01 01                                                                                                                                                                                                         |
| 12           | VMUL     | **multiply**       | rdst, rsrc | Multiplies the value of register rsrc by the value of register rdst and stores the result in the latter. Equivalent to `rdst *= rsrc`.<br>Example of squaring a number in register R1:<br>VMUL R1, R1<br>Machine code:<br>12 01 01                                                                                                                                                                 |
| 13           | VDIV     | **divide**         | rdst, rsrc | Divides the value of register rdst by the value of register rsrc and stores the result in the former. If the register rsrc contains 0, interrupt 1 is generated (INT_DIVISION_ERROR). Equivalent to `rdst /= rsrc`.<br>Example of dividing a number in R1 by 10:<br>VSET R2, 10<br>VDIV R1, R2<br>Machine code:<br>01 02 0A 00 00 00<br>13 01 02                                                   |
| 14           | VMOD     | **modulo**         | rdst, rsrc | Divides the value of register rdst by the value of register rsrc and stores the remainder of the division in the former. If the register rsrc contains 0, interrupt 1 is generated (INT_DIVISION_ERROR). Equivalent to `rdst %= rsrc`.<br>Example of obtaining the remainder from dividing the number in R1 by 10:<br>VSET R2, 10<br>VMOD R1, R2<br>Machine code:<br>01 02 0A 00 00 00<br>14 01 02 |
| 15           | VOR      | **or**             | rdst, rsrc | Stores the result of the alternative performed on each bit of the registers separately (bitwise OR) in the rdst register. Equivalent to `rdst \|= rsrc`.<br>Example of calculating the alternative of the values of registers R1 and R2:<br>VOR R1, R2<br>Machine code:<br>15 01 01                                                                                                                |
| 16           | VAND     | **and**            | rdst, rsrc | Stores the result of the conjunction performed on each bit of the registers separately (bitwise AND) in the rdst register. Equivalent to `rdst &= rsrc`.<br>Example of applying the 0x0F bitmask to register R1:<br>VSET R2, 0x0F<br>VAND R1, R2<br>Machine code:<br>01 02 0F 00 00 00<br>16 01 02                                                                                                 |
| 17           | VXOR     | **exclusive or**   | rdst, rsrc | Stores the result of the exclusive alternative performed on each bit of the registers separately (bitwise XOR) in the rdst register. Equivalent to `rdst ^= rsrc`.<br>Example of zeroing register R1:<br>VXOR R1, R1<br>Machine code:<br>17 01 01                                                                                                                                                  |
| 18           | VNOT     | **not**            | rdst       | Changes the state of all bits of the specified register to the opposite (bitwise NOT). Equivalent to `rdst = ~rdst`.<br>Example of a bitwise complement on register R5:<br>VNOT R5<br>Machine code:<br>18 05                                                                                                                                                                                       |
| 19           | VSHL     | **shift left**     | rdst, rsrc | Shifts the bits in the rdst register to the left by the number of positions specified in the rsrc register. Equivalent to `rdst <<= rsrc`.<br>Example of multiplying the value in register R1 by 8 (which means shifting the bits to the left by 3 positions):<br>VSET R2, 3<br>VSHL R1, R2<br>Machine code:<br>01 02 03 00 00 00<br>19 01 02                                                      |
| 1A           | VSHR     | **shift right**    | rdst, rsrc | Shifts the bits in the rdst register to the right by the number of positions specified in the rsrc register. Equivalent to `rdst >>= rsrc`.<br>Example of dividing the value in register R1 by 16 (which means shifting the bits to the right by 4 positions):<br>VSET R2, 4<br>VSHR R1, R2<br>Machine code:<br>01 02 04 00 00 00<br>1A 01 02                                                      |

## 3. Comparison and conditional jump instructions

| Opcode (hex) | Mnemonic     | Description                                         | Parameters | Full Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|:-------------|:-------------|:----------------------------------------------------|:-----------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 20           | VCMP         | **compare**                                         | rdst, rsrc | Compares the values of registers rdst and rsrc and saves the comparison result to the FR register (technically VCMP performs subtraction without saving the result and sets the ZF flag if the result is zero, and the CF flag if the result is less than zero; in both cases, if the condition is not met, the flag is cleared). Together with a conditional jump, this is equivalent to the high-level construct:  `if (rdst condition rsrc) goto target`  Both the actual condition and the target depend on the conditional jump used.  Example of comparing values in registers R1 and R2:  `VCMP R1, R2`  Machine code:  `20 01 02`  See also the examples provided in the description of conditional jumps further down the table.                                                                                                                                                                                 |
| 21           | VJZ<br>VJE   | **jump if zero**<br>**jump if equal**               | imm16      | Checks if the ZF flag is set - if so, the PC register is increased by imm16 (modulo 216). Otherwise, the jump is not executed and the instruction has no effect.  While the parameter in the mnemonic notation is the destination address, at the machine code level imm16 must be written as the difference between the destination address and the address of the instruction immediately following the conditional jump. Conversions between the relative jump parameter and the destination address are performed using the following two formulas:  `destination address = (jump_instruction_address + 3 + imm16) mod 216`  `imm16 = (destination address - (jump_instruction_address + 3)) mod 216`  Example of jumping to address `0x30` if the values in registers R1 and R2 are equal (assuming the address of the VJZ instruction is `0x13`):  `VCMP R1, R2`  `VJZ 0x30`  Machine code:  `20 01 02`  `21 1A 00` |
| 22           | VJNZ<br>VJNE | **jump if not zero**<br>**jump if not equal**       | imm16      | Checks if the ZF flag is cleared - if so, it performs a relative jump to the indicated location (according to the scheme described for the VJZ instruction).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 23           | VJC<br>VJB   | **jump if carry**<br>**jump if below**              | imm16      | Checks if the CF flag is set - if so, it performs a relative jump to the indicated location (according to the scheme described for the VJZ instruction).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 24           | VJNC<br>VJAE | **jump if not carry**<br>**jump if above or equal** | imm16      | Checks if the CF flag is cleared - if so, it performs a relative jump to the indicated location (according to the scheme described for the VJZ instruction).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 25           | VJBE         | **jump if below or equal**                          | imm16      | Checks if the CF or ZF flag is set (or both) - if so, it performs a relative jump to the indicated location (according to the scheme described for the VJZ instruction).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 26           | VJA          | **jump if above**                                   | imm16      | Checks if the CF flag is set and the ZF flag is cleared - if so, it performs a relative jump to the indicated location (according to the scheme described for the VJZ instruction).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |

Here's the fourth group of opcodes, wrapped in a Markdown table:

## 4. Stack operation instructions

| Opcode (hex) | Mnemonic | Mnemonic name | Parameters | Description                                                                                                                                                                                                                                                                                                      |
|:-------------|:---------|:--------------|:-----------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 30           | VPUSH    | **push**      | rsrc       | Decreases the address in the SP register by 4, and then copies 32 bits of the value from the rsrc register to the memory address pointed to by SP. Example of placing 8 zero bytes on the stack: <br> `VXOR R1, R1` <br> `VPUSH R1` <br> `VPUSH R1` <br> Machine code: <br> `17 01 01` <br> `30 01` <br> `30 01` |
| 31           | VPOP     | **pop**       | rdst       | Reads the value from the operating memory from the address pointed to by SP to the rdst register, and then increases the address in the SP register by 4. Example of retrieving a value from the stack into the R5 register: <br> `VPOP R5` <br> Machine code: <br> `31 05`                                      |

Here's the fifth category of opcodes, formatted as you requested:

## 5. Unconditional jump instructions

| Opcode (hex) | Mnemonic | Description                       | Parameters | Full Description                                                                                                                                                                                                                                                                                                                                                                                              |
|:-------------|:---------|:----------------------------------|:-----------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 40           | VJMP     | **jump**                          | imm16      | Executes a relative jump to the indicated location (according to the diagram described for the `VJZ` instruction). Equivalent of `goto` from higher-level languages.                                                                                                                                                                                                                                          |
| 41           | VJMPR    | **jump to address from register** | rsrc       | Executes an absolute jump to the address indicated in the register. Technically, it copies the value from the register rsrc (modulo 216) to the `PC` register. Example of a jump to the address `0x1234`: `VSET R1, 0x1234` `VJMPR R1` Machine code: `01 01 34 12 00 00` 41 01                                                                                                                                |
| 42           | VCALL    | **call**                          | imm16      | Saves the address of the next instruction (`PC+3`) on the stack, and then executes a relative jump to the indicated location (according to the diagram described for the `VJZ` instruction).                                                                                                                                                                                                                  |
| 43           | VCALLR   | **call an address from register** | rdst       | Saves the address of the next instruction (`PC+2`) on the stack, then executes an absolute jump to the indicated address (see also `VJMPR`).                                                                                                                                                                                                                                                                  |
| 44           | VRET     | **return**                        | none       | Retrieves an address from the stack and jumps to it. Equivalent to the pseudo-instruction `VPOP PC` or the sequence `VPOP rtmp` `VJMPR rtmp`. Example of a function call and return (assuming that the address of the `VCALL` instruction is `0x10` and the address of the label `func` is `0x40`): `VCALL func` `func:` `VSET R1, 0x1234` `VRET` Machine code: `0x10`: 42 2D 00 `0x40`: 01 01 34 12 00 00 44 |

Here's the sixth table, containing additional control instructions:

## 6. Additional control instructions

| Opcode (hex) | Mnemonic | Mnemonic name in plain English | Parameters  | Full description                                                                                                                                                                                                                                                                                                             |
|:-------------|:---------|:-------------------------------|:------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| F0           | VCRL     | **control register load**      | imm16, rsrc | Copies the value of the rsrc register to the special control register with the number imm16. In the event that the special register does not exist, exception 2 (INT_GENERAL_ERROR) will be generated. Example of setting special register 0x110 to 1: VSET R0, 1 VCRL 0x110, R0 Machine code: 01 00 01 00 00 00 F0 00 10 01 |
| F1           | VCRS     | **control register store**     | imm16, rdst | Copies the value from the special control register with the number imm16 to the destination register rdst. In the event that the special register does not exist, exception 2 (INT_GENERAL_ERROR) will be generated.                                                                                                         |
| F2           | VOUTB    | **output byte**                | imm8, rsrc  | Sends the lower byte from the rsrc register to the indicated device (port) by imm8. Example of sending the letter "A" (code 0x41) to the console: VSET R0, 0x41 VOUTB 0x20, R0 Machine code: 01 00 41 00 00 00 F2 00 20                                                                                                      |
| F3           | VINB     | **input byte**                 | imm8, rdst  | Receives the available byte from the device (port) indicated by imm8 and writes it to the rdst register. Depending on the device, the processor's operation may be suspended until a data byte appears. Example of receiving a byte from the console: VINB 0x20, R0 Machine code: F3 00 20                                   |
| F4           | VIRET    | **interrupt return**           | none        | Restores the state of the registers saved on the stack, including the PC register, thus returning to the state and place of execution where the interrupt occurred.                                                                                                                                                          |
| FF           | VOFF     | **power off**                  | none        | Interrupts the operation of the virtual machine.                                                                                                                                                                                                                                                                             |

[book]: https://github.com/gynvael/zrozumiec-programowanie
